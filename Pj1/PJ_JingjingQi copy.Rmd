---
title: "PJ_ANGSD"
author: "JingjingQi"
date: "2/13/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(data.table)
library(DESeq2)
#BiocManager::install("TxDb.Hsapiens.UCSC.hg38.knownGene")
library("TxDb.Hsapiens.UCSC.hg38.knownGene")
library(goseq)
```

```{css, echo=FALSE}
.scroll {
  max-height: 200px;
  overflow-y: auto;
}
```

### Introduction  



### Method  

###Samples and RNA Sequencing  
RNA of A549 cells-infected with Zika virus and un-infected A549 cells was isolated using RNeasy mini kit (QIAGEN, Valencia, CA, USA). RNAseq libraries were constructed using a TruSeq RNA Sample Prep V2 Kit. mRNA profiles was generated by deep sequencing, in triplicate, using Illumina Hiseq4000. All samples passed QC without triming.  

###Sequence Alignment and Gene Level Expression Quantification  
Sequence alignment and quantification of gene and exon level expression was carried out using RNA-seq analytical pipeline see _appendex_. Pair end reads were aligned to the human genome build hg38.refGene using star(2.7.0e), Star alignReads command options: --alignIntronMin 20 --alignIntronMax 1000000 --twopassMode Basic. Subread(1.6.2e) was used to count the reads mapping to individual exons according to hg38.refGene annotations (10-Jan-2020). Gene level expression was normalized by DESeq2(3.10e) Bioconductor packages, using Relative Log Expression (RLE) assuming most genes are not DE, that is calculated as the median of the ratio for each gene of its read counts over its geometric mean across all samples account for sequencing depth and RNA composition of the sample.  


### Result  

```{r, class.output="scroll", echo=F}
r_exon <- fread("featCounts_all.txt.summary")
#head(r_exon)

rename <- gsub(".Aligned.sortedByCoord.out.bam$", "", x = colnames(r_exon))
rename <- gsub("/athena/angsd/scratch/jiq4001/Pj/Star_align/", "", x = rename)
colnames(r_exon) <- rename

r_exon %>%
  filter(Status == "Assigned" | Status == "Unassigned_MultiMapping" | Status == "Unassigned_NoFeatures") %>%
  gather(-Status, key = "sample", value = "reads") %>%
  group_by(sample) %>%
  mutate(percent = round(reads/sum(reads)*100, 2)) %>%
  merge.data.frame(meta, by.x = "sample", by.y = "Run", all.x = TRUE) -> r_exon_meata

```


```{r, eval=F, echo=F}
#### bar graph alternatime
r_exon_meata %>%
  ggplot()+
  geom_bar(aes(sample, percent, fill = Status), stat = "identity", position = "stack")+
  theme(axis.text.x = element_text(angle = 90, hjust = 1),
        panel.background = element_rect(fill = "white"),
        axis.line = element_line(colour = "black")) -> p1

r_exon_meata %>%
  ggplot()+
  geom_bar(aes(sample, reads, fill = Status), stat = "identity", position = "stack")+
  theme(axis.text.x = element_text(angle = 90, hjust = 1),
        panel.background = element_rect(fill = "white"),
        axis.line = element_line(colour = "black"))-> p2


ggpubr::ggarrange(p1, p2, common.legend = T, legend = "bottom")

```
Given different sequencing platform were used NuGEN and Illumina protocol, RNAseq data with NuGEN library preparatoin method has more reads on average compare to Illumina data, with Assigned Reads count about the same level in both protocals(32302702counts by Illumina and 33137180counts by NuGEN respectively). 65.41% of the Illumina library reads was uniquely mapped to the reference genome, however, only 17.99% or the NuGEN reads was uniquely mapped. 46.98% of the reads was unassigned due to multiMapping in NuGEN protocal data, while Illumina reads has 24.83% unassigned due to multiMapping. 35.03% of the reads in NuGEN protocal data wasnt mapped to any features, but only 9.76% of the Illumina reads was not mapped to features in the annotation file.  


*Figure2. Boxplot of readscount by mapping status and librarly prep method*
```{r, echo=F, fig.align="center"}
r_exon_meata %>% 
  group_by(Status, rna_preparation) %>% 
  summarize(ave_read = mean(reads),
            sd_read = ceiling(sd(reads)),
            mean_percent_reads = round(mean(percent), 2)) ->read_summ

r_exon_meata %>%
  ggplot()+
  geom_boxplot(aes(Status, percent, color = rna_preparation),
                position = "dodge")+
  theme(panel.background = element_rect(fill = "white"),
        axis.line = element_line(colour = "black")) ->p3

r_exon_meata %>%
  ggplot()+
  geom_boxplot(aes(Status, reads, color = rna_preparation),
                position = "dodge")+
  theme(panel.background = element_rect(fill = "white"),
        axis.line = element_line(colour = "black"))->p4

ggpubr::ggarrange(p3, p4, common.legend = T, legend = "bottom")

```

*Table2. Summary of readscount by mapping status and librarly prep method*  
```{r, echo=F}
read_summ %>% kableExtra::kable(align = "c")
```



```{r, class.output="scroll", echo=F, message=F, warning=F}
# read data table
rc0 <- read.table("featCounts_all.txt", header=TRUE, row.names = NULL)


# trim extra text from colname
names(rc0) <- gsub("X.athena.angsd.scratch.jiq4001.Pj.Star_align.", "", names(rc0))
names(rc0) <- gsub(".Aligned.sortedByCoord.out.bam", "", names(rc0))

# generate rowname with GeneId
row.names(rc0) <- make.names(rc0$Geneid, unique = T) 
readcounts <- rc0[ , -c(1:6)]

r_exon_meata %>%
  arrange(rna_preparation, sample) %>%
  select(sample, involution, rna_preparation, source) %>%
  unique() %>%
  merge.data.frame(data.frame(sample = colnames(readcounts)), all.y = T) -> sampleinfo_df

##########
#seperated by library methods
##########

# create condations with colnames from readcount
poly_a <- readcounts[, 1 : 8]
names(poly_a) <- sampleinfo_df$source[1 : 8]
poly_a_info <- DataFrame(condition = sampleinfo_df$involution[sampleinfo_df$rna_preparation == "Illumina PolyA"],
row.names = names(poly_a) )

nugen <- readcounts[, 9 : 16]
names(nugen) <- sampleinfo_df$source[9 : 16]
nugen_info <- DataFrame(condition = sampleinfo_df$involution[sampleinfo_df$rna_preparation == "NuGEN Ovation"],
row.names = names(nugen) )

all <- readcounts
names(all) <- sampleinfo_df$sample
all_info <- DataFrame(involution = sampleinfo_df$involution,
                      librarymethod = sampleinfo_df$rna_preparation,
                      row.names = names(all))


# wrap reads, condation into object
DESeq.poly_a <- DESeqDataSetFromMatrix(countData = poly_a,
colData = poly_a_info,
design = ~ condition)

DESeq.nugen <- DESeqDataSetFromMatrix(countData = nugen,
colData = nugen_info,
design = ~ condition)

DESeq.all <- DESeqDataSetFromMatrix(countData = all,
colData = all_info,
design = ~ involution + librarymethod + librarymethod : involution)

# normalization
DESeq.poly_a <- estimateSizeFactors(DESeq.poly_a) 
log.norm.counts <- log2(counts(DESeq.poly_a, normalized=TRUE) + 1)
assay(DESeq.poly_a, "log.norm.counts") <- log.norm.counts


DESeq.nugen <- estimateSizeFactors(DESeq.nugen)
log.norm.counts <- log2(counts(DESeq.nugen, normalized=TRUE) + 1)
assay(DESeq.nugen, "log.norm.counts") <- log.norm.counts

DESeq.all <- estimateSizeFactors(DESeq.all)
log.norm.counts <- log2(counts(DESeq.all, normalized=TRUE) + 1)
assay(DESeq.all, "log.norm.counts") <- log.norm.counts
```

To investigate the differencially expressed genes, reads count is normalized using with contrast fomular ~ involution + librarymethod + librarymethod : involution. As shown in Fig2, readscount is highly correlated with in samples with the same library preparation methods. It is more proper to quantify the DE of genes within each method.  

```{r, eval=F, echo=F, message=F, warning=F}
DESeq.all <- DESeq(DESeq.all)
resultsNames(DESeq.all)
DESeq.all.involution <- results(DESeq.all, independentFiltering = TRUE, alpha = 0.05,
                             name = "involution_Yes_vs_No")
summary(DESeq.all.involution)

DESeq.all.librarymethod <- results(DESeq.all, independentFiltering = TRUE, alpha = 0.05,
                             name = "librarymethod_NuGEN.Ovation_vs_Illumina.PolyA")
summary(DESeq.all.librarymethod)
```
```{r, echo=F}
corr_coeff <- cor(assay(DESeq.all, "log.norm.counts"), method = "pearson")
# use cor plot dendrogram
#as.dist(1 - corr_coeff) %>% 
#  hclust %>%
#plot( ., labels = colnames(corr_coeff),
#      main = "Dendrogram of rlog transformed read counts", sub = "")

gplots::heatmap.2(corr_coeff, dendrogram = "col", trace = "none")
```


```{r, echo=F, message=F, warning=F}
DESeq.poly_a <- DESeq(DESeq.poly_a)
DESeq.poly_a.results <- results(DESeq.poly_a, independentFiltering = TRUE, alpha = 0.05)
```

```{r, echo=F, message=F, warning=F}
#DESeq.poly_a <- DESeq(DESeq.poly_a)
#DESeq.poly_a.results <- results(DESeq.poly_a, independentFiltering = TRUE, alpha = 0.05)
summary(DESeq.poly_a.results)
table(DESeq.poly_a.results$padj < 0.05)
#hist(DESeq.poly_a.results$padj)
plotMA(DESeq.poly_a.results, alpha = 0.05,
main = "Test: p.adj.value < 0.05", ylim = c(-10,10))

```

```{r, echo=F, message=F}
DESeq.poly_a.results.sorted <- DESeq.poly_a.results[order(DESeq.poly_a.results$padj), ] %>% head(n = 111) %>% data.frame()

### plot of DE genes aj-pvalue < 0.05
plot(log(DESeq.poly_a.results.sorted$baseMean), DESeq.poly_a.results.sorted$log2FoldChange, 
     col = ifelse(abs(DESeq.poly_a.results.sorted$log2FoldChange) >= 2, "red", "black"), xaxt="n")
axis(1, at = c(1, 2, 5, 10), labels = c("1e+1", "1e+02", "1e+05", "1e+10"))
abline(h = 0, col = "red")
xlab("Mean of Normalized Counts")
ylab("Log Fold Change")


DE_gene.poly_a <- DESeq.poly_a@assays@data$log.norm.counts[rownames(DESeq.poly_a.results.sorted),]
gplots::heatmap.2(DE_gene.poly_a, trace = "none")
```

```{r}
gene.vector <- ifelse(DESeq.poly_a.results$padj < 0.05, 1, 0)
names(gene.vector) <- rownames(DESeq.poly_a.results)
gene.vector <- ifelse(is.na(gene.vector), 0, gene.vector)

#glen <- rc0$Length
glen <- getlength(rownames(DESeq.poly_a.results), "hg38","geneSymbol")
#sum(gene.vector)
#length(glen)
#length(gene.vector)
gid <- rownames(rc0)
pwf <- nullp(gene.vector, id = gid, bias.data = glen)
go.wall <- goseq(pwf,"hg38","geneSymbol", use_genes_without_cat=T)
go.gns <- getgo(rownames(DESeq.poly_a.results), "hg38", "geneSymbol")%>%stack()


#merge(go.wall, go.gns, by.x = "category", by.y = "values")
#colnames(go.wall)
#colnames(go.gns)
go.wall%>%head
#supportedGeneIDs()
#supportedGenomes()
TxDb.Hsapiens.UCSC.hg38.knownGene
columns(TxDb.Hsapiens.UCSC.hg38.knownGene)
keytypes(TxDb.Hsapiens.UCSC.hg38.knownGene)


anno.DGE <- select(BSgenome.Hsapiens.UCSC.hg38, keys = )
getcl
goseq(pwf, id = gid, genome = BSgenome.Hsapiens.UCSC.hg38)
```


```{r, class.output="scroll", echo=F, message=F, warning=F}
DESeq.nugen <- DESeq(DESeq.nugen)
nugen.results <- results(DESeq.nugen, independentFiltering = TRUE, alpha = 0.05)
```

Nugen.results  
```{r, class.output="scroll", echo=F, message=F, warning=F}
#DESeq.nugen <- DESeq(DESeq.nugen)
#nugen.results <- results(DESeq.nugen, independentFiltering = TRUE, alpha = 0.05)
summary(nugen.results)
table(nugen.results$padj < 0.05)
#hist(nugen.results$padj)
plotMA(nugen.results, alpha = 0.05,
main = "Test: p.adj.value < 0.05", ylim = c(-4,4))
```


In DESeq analysis of readscount poly_a protocol data, using contrast fomular ~ condition, out of 21580 nonzero total read count, 111 with ajusted p-value < 0.05; Out of 19449 nonzero total read count in NuGEN protocal data, 165 with ajusted p-value < 0.05, with 21 commenly detected genes. Pearson correlation of the log2FoldChange between 2 conditions between the two library preparation protocols is 0.496.       



```{r, echo=F, message=F, warning=F}
merge.data.frame(data.frame(df_gene = DESeq.poly_a.results@rownames,
                            log2FoldChange.poly_a = DESeq.poly_a.results$log2FoldChange),
                 data.frame(df_gene = nugen.results@rownames,
                            log2FoldChange.nugen = nugen.results$log2FoldChange),
                 by = "df_gene", all.x = T) %>% drop_na() -> df_fc


merge.data.frame(data.frame(df_gene = DESeq.poly_a.results@rownames[which(DESeq.poly_a.results$padj < 0.05)],
                            pvalue.poly_a = DESeq.poly_a.results$padj[which(DESeq.poly_a.results$padj < 0.05)]),
                 data.frame(df_gene = nugen.results@rownames[which(nugen.results$padj < 0.05)],
                            pvalue.nugen = nugen.results$padj[which(nugen.results$padj < 0.05)]),
                 by = "df_gene", all.x = T) %>% drop_na()-> df_p


merge.data.frame(df_p, df_fc, all.x = T) -> merged
Cor = cor(merged$pvalue.poly_a, merged$pvalue.nugen) %>% round(3)
Cor_label = paste0("cor = ", Cor)

merged %>% 
  ggplot(aes(log2FoldChange.poly_a, log2FoldChange.nugen))+ 
  geom_point()+
  geom_text(aes(label = df_gene), color = "red", alpha = 0.7)+
  geom_label(aes(x = 5, y = -2.5, label = Cor_label))+
  geom_smooth(method = "lm", formula = y ~ x, se = F)+
  geom_hline(yintercept = 0, color = "black")+
  geom_vline(xintercept = 0, color = "black")+
  xlim(-15, 10)+
  ylim(-15, 10)+
  theme_bw()

```



###Appendex:  
  
###where did you get it from?   
Next Generation Sequencing Facilitates Quantitative Analysis of A549 Control and A549 infected with Zika virus Transcriptomes (human)  
https://www.ncbi.nlm.nih.gov/bioproject/PRJNA610552  
  
###what publication is it linked to?   
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6266559/  
Human Fetal Astrocytes Infected with Zika Virus Exhibit Delayed Apoptosis and Resistance to Interferon: Implications for Persistence. Daniel Limonta,1,† Juan Jovel,2,† Anil Kumar, et al.  

###who generated the data?  
Institute of Blood Transfusion, Chinese Academy of Medical Sciences and Peking Union Medical College  
###how was the NA extracted?  
RNeasy mini kit (QIAGEN, Valencia, CA, USA)   
###what library prep was used?  
TruSeq RNA Sample Prep V2 Kit  Illumina   
###what cell type was used?  
HFAs cultures between 5–7 passages were employed. A549 (human lung carcinoma)   
###what was the treatment/experimental condition? 
A549(human lung carcinoma) cells-infected with Zika virus for 28 days and aun-infected A549 cells      
###what sequencing platform was used?
Illumina Hiseq4000   
  

Record:  
Genome:  
http://hgdownload.soe.ucsc.edu/goldenPath/hg38/bigZips/hg38.2bit  
Annotation:  
http://hgdownload.soe.ucsc.edu/goldenPath/hg38/bigZips/genes/  
hg38.refGene.gtf.gz        10-Jan-2020 09:33   23M  
hg38.trf.bed.gz - Tandem Repeats Finder locations, filtered to keep repeats
    with period less than or equal to 12, and translated into UCSC's BED
    format.
genomeGenerate: --sjdbOverhang 99  
alignReads: --alignIntronMin 20 --alignIntronMax 1000000 --twopassMode Basic  
# ENCODE options default for human  
#About 5.24% of introns are more than 200,000 bp and less than 10% of introns are more than 11,000 bp in length. Also, < 0.01% of the introns are < 20 bp in length   --M.K. Sakharkar et al. / Distributions of Exons and Introns in the Human Genome  

```{r, eval=FALSE, class.output="scroll"}
#!/bin/bash
#SBATCH --nodes=1
#SBATCH --ntasks=1 --cpus-per-task=16
#SBATCH --job-name=qc_bash
#SBATCH --time=7-00:00:00
#SBATCH --mem=50G
#SBATCH --error=/athena/angsd/scratch/jiq4001/error 
spack load fastqc
spack load -r trimgalore
spack load -r py-multiqc

# set current work dir
cwd=/athena/angsd/scratch/jiq4001/Pj

mkdir ${cwd}/QC
mkdir ${cwd}/QC/non_trimed
#mkdir ${cwd}/trimed
#mkdir ${cwd}/QC/trimed
mkdir ${cwd}/multi_qc

input_dir=${cwd}/test
qc_dir=${cwd}/QC/non_trimed
#trim_dir=${cwd}/trimed
#qc_trim_dir=${cwd}/QC_trimed
multi_qc=${cwd}/multi_qc

for file in $(ls ${input_dir} | cut -b -9 | uniq -d)
do
    fastqc ${input_dir}/${file}_1.fastq.gz -o ${qc_dir} -t 16 --extract
    fastqc ${input_dir}/${file}_2.fastq.gz -o ${qc_dir} -t 16 --extract
    
    #trim_galore --illumina --stringency 5 --length 30 --paired -o ${trim_dir} ${input_dir}/${file}_1.fastq.gz ${input_dir}/${file}_2.fastq.gz
    
    #fastqc ${trim_dir}/${file}_1_val_1.fq.gz -o ${qc_trim_dir} -t 16 --extract
    #fastqc ${trim_dir}/${file}_2_val_2.fq.gz -o ${qc_trim_dir} -t 16 --extract
done

cd ${multi_qc}
multiqc ${qc_dir}
```

![](Graph/Sequence_Count.png){width=450px}, 
![](Graph/Duplication_Levels.png){width=450px}  
![](Graph/Per_Seq_Quality.png){width=450px}    
![Sequence Count](Graph/Adapter_Content.png){width=450px}    

Samples prepared by poly-A protocol showed higher duplication level, which is expected considering the add-in of adapter sequence. Since all samples passed Fastqc, no further trimming is done for downstream analysis. 
```{r, eval=FALSE, class.output="scroll"}
#!/bin/bash
#SBATCH --nodes=1
#SBATCH --ntasks=1 --cpus-per-task=16
#SBATCH --job-name=idx
#SBATCH --time=7-00:00:00
#SBATCH --mem=80G
#SBATCH --error=/athena/angsd/scratch/jiq4001/error
#SBATCH --out=/athena/angsd/scratch/jiq4001/out

spack load star@2.7.0e

cwd=/athena/angsd/scratch/jiq4001/Pj
  
mkdir ${cwd}/Star_align
sample_dir=${cwd}/test
star_align=${cwd}/Star_align

for file in $(ls ${sample_dir} | cut -b -9 | uniq -d)
do
STAR --runMode alignReads \
--runThreadN 16 \
--genomeDir ${cwd}/hg38_STARindex \
--readFilesIn ${sample_dir}/${file}_1.fastq.gz ${sample_dir}/${file}_2.fastq.gz \
--outFileNamePrefix ${star_align}/${file}. \
--outSAMattributes NH HI AS nM MD \
--twopassMode Basic \
--readFilesCommand zcat \
--outSAMtype BAM SortedByCoordinate
done
```

Alignment QC  
```{r, eval=FALSE, class.output="scroll"}
[jiq4001@farina Star_align]$spack load samtools@1.9%gcc@6.3.0

# index aligned file
[jiq4001@farina Star_align]$ for file in $(ls | egrep ".*.bam"); do  samtools index ${file}; done

#  flagstat aligned file
[jiq4001@farina Star_align]$ for file in $(ls | egrep ".*.bam$"); do samtools flagstat ${file} >> ${file}_flagstat_out; done

#!/bin/bash
#SBATCH --nodes=1
#SBATCH --ntasks=1 --cpus-per-task=16
#SBATCH --job-name=idx
#SBATCH --time=7-00:00:00
#SBATCH --mem=60G
#SBATCH --error=/athena/angsd/scratch/jiq4001/error
#SBATCH --out=/athena/angsd/scratch/jiq4001/out

cwd=/athena/angsd/scratch/jiq4001/Pj

spack load -r py-rseqc

for SAMPLE in $(ls ${cwd}/Star_align | egrep ".*.bam$")
do
read_distribution.py -i ${cwd}/Star_align/${SAMPLE} -r ${cwd}/hg38.trf.bed > ${cwd}/QC_Star_align/${SAMPLE}.read_distribution.out

geneBody_coverage.py -i ${cwd}/Star_align/${SAMPLE} -r ${cwd}/hg38.trf.bed -o ${cwd}/QC_Star_align/${SAMPLE}.geneBody_coverage.out

mismatch_profile.py -i ${cwd}/Star_align/${SAMPLE} -r ${cwd}/hg38.trf.bed -o ${cwd}/QC_Star_align/${SAMPLE}.mismatch_profile.out

done

## run multiqc .....
```

*Figure1. Gene Body Coverage*  
![](Gene_body_coverage.png){width=500px}

It appears both sequencing experiments with either library preparation methods are not able to get ideal sufficient coverage at 5'end, though the aim was not to identify low expression genes.  

Reads count   
```{r,eval=FALSE, class.output="scroll"}
#SBATCH --ntasks=1 --cpus-per-task=16
#SBATCH --job-name=idx
#SBATCH --time=7-00:00:00
#SBATCH --mem=80G
#SBATCH --error=/athena/angsd/scratch/jiq4001/error
#SBATCH --out=/athena/angsd/scratch/jiq4001/out

spack load subread

#mkdir reads_count
cwd=/athena/angsd/scratch/jiq4001/Pj
sample_dir=${cwd}/Star_align  
out_dir=${cwd}/reads_count


featureCounts -a ${cwd}/hg38.refGene.gtf \
-o ${out_dir}/featCounts_all.txt \
--minOverlap 25 \
-t "exon" \
-g "gene_id" \
--primary \
--tmpDir '/scratchLocal' \
${sample_dir}/*.bam
```
![IGV](IGV.png){width=850px}  


